# -*- coding: utf8 -*-
"""This package contains an implementation of a genetic algorithm.
"""
import random
import multiprocessing.context
import gc

import wopt.evo
import wopt.utils


class VectorIndividual(wopt.evo.Individual):
    """A class representing the individual as a list of elements.
    """

    def __init__(self, genotype, fitness=None, data=None):
        """Creates the individual.

        :param genotype: the genotype, i.e. an iterable of True/False values
            that will form the individual.
        """
        wopt.evo.Individual.__init__(self)

        self.genotype = list(genotype)
        self.fitness = fitness
        self.data = data

    def copy(self, carry_evaluation=True, carry_data=True):
        clone = VectorIndividual(self.genotype)

        wopt.evo.Individual.copy_evaluation(self, clone, carry_evaluation)
        wopt.evo.Individual.copy_data(self, clone, carry_data)
        return clone

    def __repr__(self, *args, **kwargs):
        return ('wopt.evo.ga.VectorIndividual(' + repr(self.genotype) + ', ' +
                repr(self.fitness) + ', ' + repr(self.data) + ')')


class RandomRealVectorInitializer(wopt.evo.IndividualInitializer):
    """Generates a genotype of a fixed given width with random floating-point
    values from a given distribution.
    """

    def __init__(self, length, **kwargs):
        """Creates an initializer with given parameters.

        The genotypes generated by the
        :meth:`RandomRealVectorInitializer.initialize` are going to have
        the length of ``length``.

        The optional keyword argument ``generator`` can be used to pass a
        random number generator to the initializer which is to be used for
        generation. If it is ``None`` or not present a standard generator is
        used which is the :mod:`random` module and its functions. If a
        generator is passed it is expected to have the corresponding methods
        to the :mod:`random` module (i.e. the class
        :mod:`random`\\ .Random).

        .. warning::

            If default generator is used (i.e. the methods of
            :mod:`random`) it is assumed that it is already seeded and no seed
            is set inside this class.

        :param int length: length of the genotype
        :keyword distribution: the type of distribution to draw
            from and its parameters.

            The values of this parameter are expected to be obtained by
            static methods of :class:`wopt.utils.Distribution`.

            The default value is the value of
            :meth:`wopt.utils.Distribution.uniform(0, 1)` (i.e. uniform
            distribution with bounds 0 and 1).
        :keyword generator: a random number generator; if ``None`` or not
            present calls to the methods of standard python module
            :mod:`random` will be performed instead
        :type generator: :mod:`random`\\ .Random or ``None``
        :return: a randomly generated individual
        :rtype: :class:`VectorIndividual`
        """

        wopt.evo.IndividualInitializer.__init__(self)

        self.length = length

        self.distribution = wopt.utils.Distribution.uniform(0, 1)
        if 'distribution' in kwargs:
            self.distribution = kwargs['distribution']

        self.generator = random
        if 'generator' in kwargs:
            self.generator = kwargs['generator']

    # noinspection PyUnresolvedReferences
    def initialize(self):
        genotype = [wopt.utils.Distribution.generate(self.distribution,
                                                     self.generator) for _ in
                    range(self.length)]
        return VectorIndividual(genotype)


class Ga(multiprocessing.context.Process):
    """This class forms the whole GA algorithm.
    """

    class _GenerationsStop(object):

        def __init__(self, generations):
            self.generations = generations

        def __call__(self, ga):
            if ga.mode == 'generational':
                return ga.iterations >= self.generations
            if ga.mode == 'steady-state':
                return ga.iterations >= (self.generations * ga.pop_size)

    def __init__(self, fitness, pop_size, population_initializer, mode, stop,
                 name=None, **kwargs):
        """The optional keyword argument ``generator`` can be used to pass a
        random number generator. If it is ``None`` or not present a standard
        generator is used which is the :mod:`random` module and its
        functions. If a generator is passed it is expected to have the
        methods corresponding to the :mod:`random` module (i.e. the
        class :class:`random.Random`).

        .. warning::

            The generator (does not matter whether a custom or the default
            one is used) is assumed that it is already seeded and no seed is
            set inside this class.

        :param fitness: fitness used to evaluate individual performance
        :type fitness: :class:`wopt.evo.Fitness`
        :param int pop_size: size of the population; this value will be
            passed to the ``population_initializer``'s method ``initialize``()
        :param population_initializer: initializer used to initialize the
            initial population
        :type population_initializer:
            :class:`wopt.ge.init.PopulationInitializer`
        :param mode: Specifies which mode of genetic algorithm to use. Possible
            values are:

                * ``'generational'``
                * ``'steady-state'``
        :param stop: Either a number or a callable. If it is number:

                The number of generations the algorithm will run for. One
                generation is when ``pop_size`` number of individuals were
                created and put back to the population. In other words,
                if the algorithm runs in generational mode then one
                generation is one iteration of the algorithm; if the
                algorithm runs in steady-state then one generation is half
                the ``pop_size`` iterations (because each iteration two
                individuals are selected, possibly crossed over and put back
                into the population).

            If it is a callable:

                The callable will be called at the beginning of each
                iteration of the algorithm with one argument which is the
                algorithm instance (i.e. instance of this class). If the
                return value is evaluated as ``True`` then the algorithm stops.
        :param str name: name of the process (see
            :class:`multiprocessing.Process`)
        :keyword generator: (keyword argument) a random number generator; if
            ``None`` or not present calls to the methods of standard python
            module :mod:`random` will be performed instead
        :type generator: :class:`random.Random` , or ``None``
        :keyword int elites_num: (keyword argument) the number of best
            individuals to be copied directly to the next generation; if it
            is lower then 0 it is set to 0; default value is 0
        :keyword int tournament_size: (keyword argument) the size of
            tournament for tournament selection; if it is lower than 2 it is
            set to 2; default value is 2
        :keyword crossover_prob: (keyword argument) probability of performing a
            crossover; if it does not fit into interval [0, 1] it is set to 0 if
            lower than 0 and to 1 if higher than 1; default value is 0.8
        :keyword crossover_type: (keyword argument) the type of crossover;
            possible values are

                * ``'uniform'`` - uniform crossover
                * ``('point', N)`` or just ``'point'`` - multi-point crossover,
                  with `N` being the number of points; the second variant
                  uses 1 for N (i.e. single-point crossover)
                * ``'mean'`` - mean crossover (treats the individuals as
                  real-valued vectors)
                * ``('blx', alpha)`` or just ``blx`` - blend (BLX-alpha)
                  crossover (treats the individuals as real-valued vectors),
                  with `alpha` being the alpha parameter; the second variant
                  uses 0.5 as the value of alpha

            The default value is ``'point'`` if the individual is detected
            to be a binary (boolean) vector, and ``'blx'`` in other cases.
        :keyword mutation_prob: (keyword argument) probability of performing
            a mutation; if it does not fit into interval [0, 1] it is set to
            0 if lower than 0 and to 1 if higher than 1; default value is 0.1

            Note: the probability is of the act of mutating one variable in
            the genotype, not of the act of performing a mutation on the
            genotype as a whole.
        :keyword mutation_type: (keyword argument) the type of mutation;
            possible values are

                * ``('gaussian', sigma)`` or just ``'gaussian'`` - gaussian
                  mutation (treats the individuals as real-valued vectors),
                  i.e. each variable is generated from a gaussian
                  distribution with the mu value equal to the original value
                  and the given sigma value. The second variant uses 1 as the
                  value of sigma.

                  The second variant uses 1 as the value of sigma
                * ``'flip'`` - bit-flip mutation (treats the individuals as
                  boolean lists)

            The default type is ``'flip'`` if the individual is detected
            to be a binary (boolean) vector, and ``'gaussian'`` in other cases.
        :keyword steady_state_replace: (keyword argument) the replacement
            strategy when using steady-state mode of evolution (i.e. ``mode`` is
            set to ``'steady-state'``); possible values are

                * ``'random'`` - an offspring replaces a random member of the
                  population
                * ``('inverse-tournament', N, incl)`` or just
                  ``'inverse-tournament'`` - an offspring replaces an
                  individual selected by a tournament of size N with reversed
                  fitness meaning (i.e. the worst "wins"). The ``incl``
                  parameter indicates whether the offspring should be part of
                  the tournament. If it is and it looses, it is not put into
                  the population at all.

                  The second variant uses the value of ``tournament_size``
                  keyword argument as the value of N and ``false`` as the
                  value of the ``incl`` parameter.

            The default value is ``'random'``.
        :param stats: stats saving class
        :type stats: :class:`wopt.evo.support.Stats`
        :param callback: a callable which will be called at the end of every
            generation with a single argument which is the algorithm instance
            itself (i.e. instance of this class)
        """
        super().__init__(name=name)

        # Positional args
        self.fitness = fitness
        self.pop_size = pop_size
        self.population_initializer = population_initializer
        self.mode = mode
        if mode not in ['generational', 'steady-state']:
            raise ValueError('Argument mode must be one of \'generational\' '
                             'or \'steady-state\'')
        if isinstance(stop, int):
            # noinspection PyProtectedMember
            self.stop = Ga._GenerationsStop(stop)
        elif callable(stop):
            self.stop = stop
        else:
            raise TypeError('Argument stop is neither integer nor callable.')

        # Keyword args
        self.generator = random
        if 'generator' in kwargs:
            self.generator = kwargs['generator']

        self.elites_num = 0
        if 'elites_num' in kwargs:
            if not isinstance(kwargs['elites_num'], int):
                raise ValueError('Number of elites must be an integer.')
            self.elites_num = kwargs['elites_num']
            self.elites_num = max(0, self.elites_num)

        self.tournament_size = 2
        if 'tournament_size' in kwargs:
            if not isinstance(kwargs['tournament_size'], int):
                raise ValueError('Tournament size must be an integer.')
            self.tournament_size = kwargs['tournament_size']
            self.tournament_size = max(2, self.tournament_size)

        self.crossover_prob = 0.8
        if 'crossover_prob' in kwargs:
            self.crossover_prob = kwargs['crossover_prob']
            self.crossover_prob = max(0, self.crossover_prob)
            self.crossover_prob = min(1, self.crossover_prob)

        self.crossover_method = None
        if 'crossover_type' in kwargs and kwargs['crossover_type'] is not None:
            ct = kwargs['crossover_type']
            if ct == 'uniform':
                self.crossover_method = self.uniform_crossover
                self.crossover_method_args = ()
            elif ct == 'point':
                self.crossover_method = self.point_crossover
                self.crossover_method_args = (1,)
            elif ct == 'mean':
                self.crossover_method = self.mean_crossover
                self.crossover_method_args = ()
            elif ct == 'blx':
                self.crossover_method = self.blx_crossover
                self.crossover_method_args = (0.5,)
            elif ct[0] == 'point':
                try:
                    self.crossover_method = self.point_crossover
                    self.crossover_method_args = (int(ct[1]),)
                except:
                    raise ValueError('Invalid N parameter for point crossover')
            elif ct[0] == 'blx':
                try:
                    self.crossover_method = self.blx_crossover
                    self.crossover_method_args = (float(ct[1]),)
                except:
                    raise ValueError('Invalid alpha parameter for blend '
                                     'crossover')
            else:
                raise ValueError('Invalid crossover type.')

        self.mutation_prob = 0.1
        if 'mutation_prob' in kwargs:
            self.mutation_prob = kwargs['mutation_prob']
            self.mutation_prob = max(0, self.mutation_prob)
            self.mutation_prob = min(1, self.mutation_prob)

        self.mutate_method = None
        if 'mutation_type' in kwargs and kwargs['mutation_type'] is not None:
            mt = kwargs['mutation_type']
            if mt == 'gaussian':
                self.mutate_method = self.gaussian_mutate
                self.mutate_method_args = (1,)
            elif mt == 'flip':
                self.mutate_method = self.flip_mutate
                self.mutate_method_args = ()
            elif mt[0] == 'gaussian':
                try:
                    self.mutate_method = self.gaussian_mutate
                    self.mutate_method_args = (float(mt[1]),)
                except:
                    raise ValueError('Invalid sigma parameter for gaussian '
                                     'mutation')
            else:
                raise ValueError('Invalid mutation type.')

        self.replace_method = self.random_replace
        self.replace_method_args = ()
        if 'steady_state_replace' in kwargs:
            ssr = kwargs['steady_state_replace']
            if ssr == 'random':
                self.replace_method = self.random_replace
                self.replace_method_args = ()
            elif ssr == 'inverse-tournament':
                self.replace_method = self.inverse_tournament_replace
                self.replace_method_args = (self.tournament_size, False)
            elif ssr[0] == 'inverse-tournament':
                try:
                    self.replace_method = self.inverse_tournament_replace
                    self.replace_method_args = (int(ssr[1]), bool(ssr[2]))
                except:
                    raise ValueError('Invalid parameters for inverse '
                                     'tournament replacement strategy.')
            else:
                raise ValueError('Invalid steady state replacement strategy.')

        self.stats = None
        if 'stats' in kwargs:
            self.stats = kwargs['stats']

        self.callback = None
        if 'callback' in kwargs:
            self.callback = kwargs['callback']
            if not callable(self.callback):
                raise TypeError('Keyword argument callback is not a callable.')

        self.population = []
        self.bsf = None
        self.iterations = 0

    def run(self):
        """Runs the GA algorithm.
        """
        try:
            self.population = self.population_initializer.initialize(
                self.pop_size)

            if self.mode == 'generational':
                self._run_generational()
            elif self.mode == 'steady-state':
                self._run_steady_state()
        finally:
            gc.collect()
            try:
                self.stats.cleanup()
            except AttributeError:
                pass

    def _run_generational(self):
        while not self.stop(self):
            if self.callback is not None:
                self.callback(self)
            elites = self.extract_elites()

            others = []
            while True:
                o1 = self.select_tournament(self.population,
                                            self.tournament_size).copy()
                o2 = self.select_tournament(self.population,
                                            self.tournament_size).copy()

                os = self.crossover(o1, o2)

                for o in os:
                    self.mutate(o)
                    if self.pop_size - (len(others) + len(elites)) > 0:
                        others.append(o)
                else:
                    break
            self.population = elites + others
            self.iterations += 1

    def _run_steady_state(self):
        for i in self.population:
            self.evaluate(i)

        self.fitness.sort(self.population)

        while not self.stop(self):
            if self.callback is not None:
                self.callback(self)
            o1 = self.select_tournament(self.population).copy()
            o2 = self.select_tournament(self.population).copy()

            os = self.crossover(o1, o2)

            for o in os:
                self.mutate(o)
                self.replace(o)
            self.iterations += 1

    def evaluate(self, individual):
        self.fitness.evaluate(individual)
        if self.bsf is None or self.fitness.compare(individual.get_fitness(),
                                                    self.bsf.get_fitness()):
            self.bsf = individual
            self.stats.save_bsf(self.iterations, self.bsf)

    def extract_elites(self):
        if self.elites_num == 0:
            return []

        for individual in self.population:
            if individual.get_fitness() is None:
                self.evaluate(individual)

        self.fitness.sort(self.population, reverse=False)
        return self.population[0:self.elites_num]

    def select_tournament(self, population, size, inverse=False, sorted_=True):
        return population[self.select_tournament_idx(population, size,
                                                     inverse, sorted_)]

    def select_tournament_idx(self, population, size,
                              inverse=False, sorted_=True):
        candidates_idx = self.generator.sample(range(len(population)), size)
        if sorted_:
            if inverse:
                return max(candidates_idx)
            return min(candidates_idx)
        best_idx = None
        best_f = None
        for candidate_idx in candidates_idx:
            candidate = population[candidate_idx]
            if candidate.get_fitness() is None:
                self.evaluate(candidate)

            better = self.fitness.compare(candidate.get_fitness(), best_f)
            if best_idx is None or (bool(inverse) ^ bool(better)):
                best_idx = candidate_idx
                best_f = candidate.get_fitness()
        return best_idx

    def crossover(self, i1, i2):
        if self.generator.random() >= self.crossover_prob:
            return [i1, i2]
        if self.crossover_method is None:
            if (all(map(lambda x: (not (not x)) == x, i1.genotype)) and
                    all(map(lambda x: (not (not x)) == x, i2.genotype))):
                return self.point_crossover(i1, i2, 1)
            else:
                return self.blx_crossover(i1, i2, 0.5)
        return self.crossover_method(i1, i2, *self.crossover_method_args)

    def uniform_crossover(self, i1, i2):
        if len(i1.genotype) != len(i2.genotype):
            raise ValueError('Genotypes must be of equal lengths.')

        for i, (a1, a2) in enumerate(zip(i1.genotype, i2.genotype)):
            if self.generator.random() < 0.5:
                i1.genotype[i], i2.genotype[i] = a2, a1
                i1.set_fitness(None)
                i2.set_fitness(None)
        return [i1, i2]

    def point_crossover(self, i1, i2, n):
        if len(i1.genotype) != len(i2.genotype):
            raise ValueError('Genotypes must be of equal lengths.')

        points = sorted(self.generator.sample(range(1, len(i1.genotype)), n))
        points.append(len(i1.genotype))

        for p1, p2 in zip(points[0::2], points[1::2]):
            i1.genotype[p1:p2], i2.genotype[p1:p2] = (i2.genotype[p1:p2],
                                                      i1.genotype[p1:p2])
        i1.set_fitness(None)
        i2.set_fitness(None)
        return [i1, i2]

    def mean_crossover(self, i1, i2):
        if len(i1.genotype) != len(i2.genotype):
            raise ValueError('Genotypes must be of equal lengths.')

        g = [None] * len(i1.genotype)
        for i, (a1, a2) in enumerate(zip(i1.genotype, i2.genotype)):
            g[i] = (a1 + a2) / 2
        return [VectorIndividual(g)]

    def blx_crossover(self, i1, i2, alpha):
        if len(i1.genotype) != len(i2.genotype):
            raise ValueError('Genotypes must be of equal lengths.')

        g = [None] * len(i1.genotype)
        for i, (a1, a2) in enumerate(zip(i1.genotype, i2.genotype)):
            cmax = max(a1, a2)
            cmin = min(a1, a2)
            d = cmax - cmin
            g[i] = self.generator.uniform(cmin - d * alpha, cmax + d * alpha)
        return [VectorIndividual(g)]

    def mutate(self, individual):
        if self.crossover_method is None:
            if all(map(lambda x: (not (not x)) == x, individual.genotype)):
                return self.flip_mutate(individual)
            else:
                return self.gaussian_mutate(individual, 1)
        self.mutate_method(individual, *self.mutate_method_args)

    def gaussian_mutate(self, individual, sigma):
        for i, a in enumerate(individual.genotype):
            if self.generator.random() < self.mutation_prob:
                individual.genotype[i] = self.generator.gauss(a, sigma)
                individual.set_fitness(None)

    def flip_mutate(self, individual):
        for i, a in enumerate(individual.genotype):
            if self.generator.random() < self.mutation_prob:
                individual.genotype[i] = not a
                individual.set_fitness(None)

    def replace(self, indiv):
        self.replace_method(indiv, *self.replace_method_args)

    def random_replace(self, indiv):
        self._pop_replace(self.generator.randrange(len(self.population)), indiv)

    def inverse_tournament_replace(self, indiv, n, participate):
        if participate:
            loser_idx = self.select_tournament_idx(self.population, n - 1, True)
            loser = self.population[loser_idx]
            if self.fitness.compare(indiv.get_fitness(), loser.get_fitness()):
                self._pop_replace(loser_idx, indiv)
        else:
            loser_idx = self.select_tournament_idx(self.population, n, True)
            self._pop_replace(loser_idx, indiv)

    def _pop_insert(self, indiv):
        """Inserts an individual into the sorted population.
        """
        if indiv.get_fitness() is None:
            self.evaluate(indiv)

        # is it worse than the worst?
        if self.fitness.compare(self.population[-1].get_fitness(),
                                indiv.get_fitness()):
            self.population.append(indiv)
            return

        # is it better than the best?
        if self.fitness.compare(indiv.get_fitness(),
                                self.population[0].get_fitness()):
            self.population.insert(0, indiv)
            return

        # find the appropriate place by bisection
        l = 0
        u = len(self.population)
        c = (l + u) // 2
        while l < u and l != c != u:
            ci = self.population[c]
            if self.fitness.compare(ci.get_fitness(), indiv.get_fitness()):
                l = c
            elif self.fitness.compare(indiv.get_fitness(), ci.get_fitness()):
                u = c
            else:
                break
            c = (l + u) // 2
        self.population.insert(c + 1, indiv)

    def _pop_replace(self, replace_idx, indiv):
        """Removes the individual at ``replace_idx`` and inserts ``indiv``
        into the sorted population.
        """
        if indiv.get_fitness() is None:
            self.evaluate(indiv)

        # if the indiv fits to the place of replace_idx then put it there
        ln = None  # left neighbor
        rn = None  # right neighbor
        if replace_idx > 0:
            ln = self.population[replace_idx - 1]
        if replace_idx < len(self.population) - 1:
            rn = self.population[replace_idx + 1]

        left_fit = ln is not None and self.fitness.compare(ln.get_fitness(),
                                                           indiv.get_fitness())
        right_fit = rn is not None and self.fitness.compare(indiv.get_fitness(),
                                                            rn.get_fitness())
        if left_fit and right_fit:
            self.population[replace_idx] = indiv
            return

        # else just remove the individual at replace_idx and do a regular
        # insert to the population
        self.population.remove(replace_idx)
        self._pop_insert(indiv)